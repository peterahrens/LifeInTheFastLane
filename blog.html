<!DOCTYPE html>
<html>
  <head>
    <title>Life in the fast lane</title>
  </head>
  <body>

    <h1>Life in the fast lane</h1>

    <p>Conway's Game of Life has been an inspiration to computer scientists since it's creation in 1970. Life is a simulation of cells arranged in a two-dimensional grid. Each cell can be in one of two states, alive or dead. I will leave the <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">full explanation</a> of Life to Wikipedia, and only restate here the rules regarding the interactions between cells:</p>

    <ul>
      <li>Any live cell with fewer than two live neighbours dies, as if caused by under-population.</li>
      <li>Any live cell with two or three live neighbours lives on to the next generation.</li>
      <li>Any live cell with more than three live neighbours dies, as if by over-population.</li>
      <li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li>
    </ul>

    <p>Note that in our implementation of Life, like many others, the environment wraps around to the other side at the edges, like in Pac-Man.</p>

    <p>This text serves as an explanation of my process in getting very good performance out of Life. To make this guide representative of many problems in performance optimization for scientific kernels, I have disallowed myself from pursuing algorithmic optimizations (that said, if you haven't seen <a href="https://en.wikipedia.org/wiki/Hashlife">Hashlife</a>, it is worth checking out). All the optimzation techniques you see here should be applicable to a wide variety of codes, and will focus on optimizing the naive algorithm for a given architecture. </p>

    <p>I should give anyone reading this guide an important warning before I start. These techniques can make the code go faster, but they increase code complexity by several orders of magnitude and tend to need different tunings for different machines. If someone else has written an optimized version of code that does what you want to do, I would strongly reccomend you use that code before trying the techniques you see here. Use optimized libraries, don't write them unless it is your job. </p>

    <h2>reference.c</h2>

    <p>Like many logical simulations, life is fully deterministic. This means that we can determine if our simulation is correct by comparing our output to a reference implementation. The reference implementation we use will also provide a starting point for optimization. The reference implementation I use has been adapted from the <a href="http://rosettacode.org/wiki/Conway's_Game_of_Life#C">RosettaCode</a> C implementation. Rather than expound on the code for ages, I will let you read it yourself. Explanatory comments are included.

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;stdlib.h&gt;</span>

<span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">reference_life</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> height,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>initial,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> iters) {
  <span style="color: #888888">//&quot;universe&quot; is the current game of life grid. We will store &quot;alive&quot; as a 1</span>
  <span style="color: #888888">//and &quot;dead&quot; as a 0.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>universe <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);

  <span style="color: #888888">//&quot;new&quot; is a scratch array to store the next iteration as it is calculated.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>new <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);

  <span style="color: #888888">//We must load the initial configuration into the universe memory.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
      universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> initial[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
    }
  }

  <span style="color: #888888">//The main loop: a likely target for later optimization.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        <span style="color: #888888">//Here we loop over the neighbors and count how many are alive.</span>
        <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> yy <span style="color: #333333">=</span> y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy <span style="color: #333333">&lt;=</span> y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> xx <span style="color: #333333">=</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx <span style="color: #333333">&lt;=</span> x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx<span style="color: #333333">++</span>) {
            <span style="color: #888888">//This is a redundant way to perform this operation. Since &quot;alive&quot;</span>
            <span style="color: #888888">//is represented as 1 and &quot;dead&quot; is represented as 0, we can just</span>
            <span style="color: #888888">//add universe[...] to n without the conditional branch.</span>
            <span style="color: #008800; font-weight: bold">if</span> (universe[((yy <span style="color: #333333">+</span> height) <span style="color: #333333">%</span> height) <span style="color: #333333">*</span> width
                         <span style="color: #333333">+</span> ((xx <span style="color: #333333">+</span> width) <span style="color: #333333">%</span> width)]) {
              n<span style="color: #333333">++</span>;
            }
          }
        }
        <span style="color: #888888">//This statement is to avoid counting a cell as a neighbor of itself.</span>
        <span style="color: #008800; font-weight: bold">if</span> (universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]) {
          n<span style="color: #333333">--</span>;
        }
        <span style="color: #888888">//This fairly tight logic determines the status of the cell in the next </span>
        <span style="color: #888888">//iteration. We have to store this in a new array to avoid modifying</span>
        <span style="color: #888888">//the original array as we calculate the new one.</span>
        new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]));
      }
    }
    <span style="color: #888888">//These loops copy the new state array into the current state array,</span>
    <span style="color: #888888">//completing an iteration.</span>
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
      }
    }
  }
  free(new);
  <span style="color: #008800; font-weight: bold">return</span> universe;
}
</pre></div>


    <p>As you can see, there are several problems with the reference implementation. It has lots of conditional and arithmetic logic in the inner loop and it copies the entire universe every iteration. However, it is easy to understand, and it is correct (two properties not everyone can say of their code!). We will only be using the reference code to check correctness of our optimized versions and to have something to compare to.


    <h2>bench.c</h2>

    <p>When optimizing code, it is also important to have benchmarking and test code. Having an accurate benchmark that tests a common case for your code gives you the information you need to make optimization decisions. Our benchmark code includes test code as well. Rather than paste the whole file, I'll only include the highlights here.</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">//Return time time of day as a double-precision floating point value.</span>
<span style="color: #333399; font-weight: bold">double</span> <span style="color: #0066BB; font-weight: bold">wall_time</span> (<span style="color: #333399; font-weight: bold">void</span>) {
  <span style="color: #008800; font-weight: bold">struct</span> timeval t;
  <span style="color: #888888">//It is critically important to use an accurate timer. Many common functions</span>
  <span style="color: #888888">//that return the time are not accurate enough for timing code. Since timers</span>
  <span style="color: #888888">//are typically system-specific, research timers for your system.</span>
  <span style="color: #888888">//Surprisingly, omp_get_wtime() is quite good and is available everywhere</span>
  <span style="color: #888888">//there is OpenMP.</span>
  gettimeofday(<span style="color: #333333">&amp;</span>t, <span style="color: #007020">NULL</span>);
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #6600EE; font-weight: bold">1.0</span><span style="color: #333333">*</span>t.tv_sec <span style="color: #333333">+</span> <span style="color: #6600EE; font-weight: bold">1.0e-6</span><span style="color: #333333">*</span>t.tv_usec;
}
</pre></div>


    <p> Note that in our benchmark, <code>TIMEOUT</code> is set to 0.1 seconds</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">double</span> test_time <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>test;

  <span style="color: #888888">//We must run the benchmarking application for a sufficient length of time</span>
  <span style="color: #888888">//to avoid small variations in processing speed. We do this by running an</span>
  <span style="color: #888888">//increasing number of trials until it takes at least TIMEOUT seconds.</span>
  <span style="color: #008800; font-weight: bold">for</span> (trials <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>; test_time <span style="color: #333333">&lt;</span> TIMEOUT; trials <span style="color: #333333">*=</span> <span style="color: #0000DD; font-weight: bold">2</span>) {

    <span style="color: #888888">//Unless you want to measure the cache warm-up time, it is usually a good</span>
    <span style="color: #888888">//idea to run the problem for one iteration first to load the problem</span>
    <span style="color: #888888">//into cache.</span>
    test <span style="color: #333333">=</span> life(height, width, initial, <span style="color: #0000DD; font-weight: bold">1</span>);
    free(test);

    <span style="color: #888888">//Benchmark &quot;trials&quot; runs of life.</span>
    test_time <span style="color: #333333">=</span> <span style="color: #333333">-</span>wall_time();
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> trials <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; <span style="color: #333333">++</span>i){
      test <span style="color: #333333">=</span> life(height, width, initial, iters);
      free(test);
    }
    test <span style="color: #333333">=</span> life(height, width, initial, iters);
    test_time <span style="color: #333333">+=</span> wall_time();
  }
  trials <span style="color: #333333">/=</span> <span style="color: #0000DD; font-weight: bold">2</span>;
  test_time <span style="color: #333333">/=</span> trials;
</pre></div>

    <p>As you can see, writing good benchmark code is more complicated than slapping a timer on both sides of the loop.</p>

    <h2>simple.c</h2>

    Becaues optimization make code complicated, it is adviseable to simplify the code whenever possible. Before we start heavily optimizing the reference implementation, we can fix the glaring flaws in the reference implementation. Here is the new inner loop:

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i <span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> yy <span style="color: #333333">=</span> y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy <span style="color: #333333">&lt;=</span> y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> xx <span style="color: #333333">=</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx <span style="color: #333333">&lt;=</span> x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx<span style="color: #333333">++</span>) {
              <span style="color: #888888">//Directly add &quot;universe&quot; values to &quot;n&quot;</span>
              n <span style="color: #333333">+=</span> universe[((yy <span style="color: #333333">+</span> height) <span style="color: #333333">%</span> height) <span style="color: #333333">*</span> width
                            <span style="color: #333333">+</span> ((xx <span style="color: #333333">+</span> width) <span style="color: #333333">%</span> width)];
            }
          }
          n <span style="color: #333333">-=</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
          new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]));
      }
    }
    <span style="color: #888888">//Instead of copying &quot;new&quot; into universe every time, just swap the pointers</span>
    <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
    universe <span style="color: #333333">=</span> new;
    new <span style="color: #333333">=</span> tmp;
  }
</pre></div>

    <p>On a 4096x4096 grid for 256 iterations, these optimizations provide a x speedup over the reference implementation.</p>

    <h2>padding.c</h2>

    <p>Finally, we are ready to implement our first real optimization! Typically, codes spend a lot of their time in the inner loop. Our inner loop includes complicated modular arithmetic on indicies and a doubly-nested for loop. Let's fix this! We can do this using a technique called "padding". In short, instead of looking to the other side of the universe to wrap around in the inner loop, we will allocate an array with extra cells on all sides ("ghost cells") and fill these cells with values from the other side of the array. That way, when the inner loop accesses beyond the the edges of the universe, it looks like the universe is wrapping around.</p>

    <p>Each time we perform an iteration, we lose the outer layer of ghost cells, since they are no longer valid (we did not calculate anything on the outermost layer of the array). To avoid copying with every iteration, we can pad with multiple ghost cell layers at once, and then run several iterations before copying again.</p>

    <p>The code is significantly more complicated now. If you don't understand everything at first, that's okay. Try to get the main ideas from the code, and understand the comments. Note that this code assumes that <code>width</code> is a multiple of <code>sizeof(unsigned)</code>.</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;stdint.h&gt;</span>


<span style="color: #557799">#define             WORD sizeof(unsigned)</span>
<span style="color: #888888">//OUT_GHOST is the width of the valid ghost cells after copying IN_GHOST ghost</span>
<span style="color: #888888">//cell values to the border and then executing one iteration. The kernel will</span>
<span style="color: #888888">//copy IN_GHOST ghost cells, then run IN_GHOST iterations before copying ghost</span>
<span style="color: #888888">//cells again. OUT_GHOST can be any value greater than or equal to 0.</span>
<span style="color: #557799">#define        OUT_GHOST 0</span>
<span style="color: #557799">#define         IN_GHOST (OUT_GHOST + 1)</span>
<span style="color: #557799">#define       X_IN_GHOST ((OUT_GHOST/WORD + 1) * WORD)</span>
<span style="color: #557799">#define       Y_IN_GHOST IN_GHOST</span>
<span style="color: #557799">#define X_IN_GHOST_WORDS (X_IN_GHOST/WORD)</span>

<span style="color: #888888">//There are platform specific aligned malloc implementations, but it is</span>
<span style="color: #888888">//instructive to see one written out explicitly. Allocates memory, then rounds</span>
<span style="color: #888888">//it to a multiple of WORD. Stores a pointer to the original memory to free it.</span>
<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">aligned_malloc</span>(<span style="color: #333399; font-weight: bold">int</span> size) {
    <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">*</span>mem <span style="color: #333333">=</span> malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> size <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>);
    <span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">**</span>ptr <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)(((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(mem <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)) <span style="color: #333333">&amp;</span> <span style="color: #333333">~</span>((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)));
    ptr[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> mem;
    <span style="color: #008800; font-weight: bold">return</span> ptr;
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">aligned_free</span>(<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span>ptr) {
    free(((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)ptr)[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>]);
}

<span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">life</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> height,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span> <span style="color: #008800; font-weight: bold">const</span> initial,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> iters) {
  <span style="color: #888888">//Padding makes things ridiculously complicated. These constant values</span>
  <span style="color: #888888">//make life a little easier.</span>
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_height <span style="color: #333333">=</span> height <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> Y_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_width <span style="color: #333333">=</span> width <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> X_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width_words <span style="color: #333333">=</span> width<span style="color: #333333">/</span>WORD;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_width_words <span style="color: #333333">=</span> padded_width<span style="color: #333333">/</span>WORD;

  <span style="color: #888888">//Oh! The careful reader will notice that I am allocating an array of</span>
  <span style="color: #888888">//byte-size ints! In addition to preparing us for vectorization later, this</span>
  <span style="color: #888888">//also reduces memory traffic.</span>
  <span style="color: #888888">//Also, this memory is aligned. Aligned memory access is typically faster</span>
  <span style="color: #888888">//that unaligned. To keep the memory aligned on each row, we have to pad</span>
  <span style="color: #888888">//to a multiple of the word size. We also assume the input matrix has a width</span>
  <span style="color: #888888">//that is a multiple of the word size.</span>
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>universe <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(padded_height <span style="color: #333333">*</span> padded_width);
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>new <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(padded_height <span style="color: #333333">*</span> padded_width);

  <span style="color: #888888">//Pack unsigned into the padded working array of uint8_t.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST; x<span style="color: #333333">++</span>) {
      universe[(y <span style="color: #333333">*</span> padded_width) <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> initial[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST];
    }
  }

  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i <span style="color: #333333">+=</span> IN_GHOST) {

    <span style="color: #888888">//Copy the ghost cells once every IN_GHOST iterations. I have not only</span>
    <span style="color: #888888">//simplified much of the logic (no more mod operations!), I have also</span>
    <span style="color: #888888">//reduced the number of instructions necessary to copy by casting the</span>
    <span style="color: #888888">//uint8_t array to unsigned and working with these larger values of a size</span>
    <span style="color: #888888">//the system is used to working with.</span>
    <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>universe_words <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)universe;
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> padded_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> Y_IN_GHOST) {
        <span style="color: #888888">//Top left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Top middle</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x];
        }
        <span style="color: #888888">//Top right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST) {
        <span style="color: #888888">//Middle left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Middle right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      } <span style="color: #008800; font-weight: bold">else</span> {
        <span style="color: #888888">//Bottom left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Bottom middle</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x];
        }
        <span style="color: #888888">//Bottom right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      }
    }

    <span style="color: #888888">//The valid ghost zone shrinks by one with each iteration.</span>
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;&amp;</span> i <span style="color: #333333">+</span> j <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; x<span style="color: #333333">++</span>) {
          <span style="color: #888888">//The inner loop gets much simpler when you pad the array, doesn&#39;t it?</span>
          <span style="color: #888888">//This is the main reason people pad their arrays before computation.</span>
          <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
          <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
          <span style="color: #888888">//Note that constant offsets into memory are faster.</span>
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          <span style="color: #333399; font-weight: bold">unsigned</span> alive <span style="color: #333333">=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          new[y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> alive));
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
  }

  <span style="color: #888888">//Unpack uint8_t into output array of unsigned.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>out <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST; x<span style="color: #333333">++</span>) {
      out[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST] <span style="color: #333333">=</span> universe[(y <span style="color: #333333">*</span> padded_width) <span style="color: #333333">+</span> x];
    }
  }

  aligned_free(new);
  aligned_free(universe);
  <span style="color: #008800; font-weight: bold">return</span> out;
}
</pre></div>

    <p>On a 4096x4096 grid for 256 iterations, this code achieves our first significant speedup of x over the reference version!</p>

    <h2>blocked.c</h2>
    <p>Our code tends to progress linearly across each row, accessing only the rows above and below it. Life needs to access each element nine times (eight times while counting among neighbors, and once to calculate the cell itself). As computation proceeds row by row, these accesses occur in groups of three (once group for each row), and if three rows of the matrix can fit in L1 cache, then the data is only loaded once from cache per iteration. However, if our computation accessed the data many more times per iteration, it might benefit from a technique called blocking. </p>
    <p>Blocking is the practice of grouping the memory accesses together to keep the data in the highest level of the memory hierarchy possible. Register blocking is the reuse of data while it is still in the registers. Register blocking occurs in the inner loop of your code when you reuse values you have loaded from memory instead of loading them multiple times. Cache blocking is the reuse of data while it resides in cache. Cache blocking can be achieved by restructuring the ordering of loops so that nearby values are accessed soon after each other. Typically, you want a cache block to take up a sizeable portion of your L1 cache. </p>
    <p>Although it doesn't help much in our case (the loop logic overhead exceeds memory benefits), we show an example of how to restructure the padded inner loop for cache blocking:</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#define          X_BLOCK WORD * 256</span>
<span style="color: #557799">#define          Y_BLOCK 256</span>
</pre></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;&amp;</span> i <span style="color: #333333">+</span> j <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #888888">//Now the outer loops progress block by block.</span>
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; y <span style="color: #333333">+=</span> Y_BLOCK) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; x <span style="color: #333333">+=</span> X_BLOCK) {
          <span style="color: #888888">//The inner loops progress one by one.</span>
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> yy <span style="color: #333333">=</span> y; yy <span style="color: #333333">&lt;</span> y <span style="color: #333333">+</span> Y_BLOCK <span style="color: #333333">&amp;&amp;</span> yy <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; yy<span style="color: #333333">++</span>) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> xx <span style="color: #333333">=</span> x; xx <span style="color: #333333">&lt;</span> x <span style="color: #333333">+</span> X_BLOCK <span style="color: #333333">&amp;&amp;</span> xx <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; xx<span style="color: #333333">++</span>) {
              <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
              <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (yy <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> xx <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              u <span style="color: #333333">+=</span> padded_width;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              <span style="color: #333399; font-weight: bold">unsigned</span> alive <span style="color: #333333">=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              u <span style="color: #333333">+=</span> padded_width;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              new[yy <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> xx] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> alive));
            }
          }
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
</pre></div>

    <h2>sse2.c</h2>
    <p>Now, we will cram more operations into the inner loop using vectorization. This is our first form of explicit parallelism, at the instruction level. Intel's <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> vector intrinsics are 128 bits wide, so we can cram 16 <code>uint8_t</code> types into a single vector register, and operate on them all at once. To keep the code nice, we require that the width of the input is a multiple of 16. Specifically, we are using SSE2. A good resource for Intel vector intrinsics is the <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#">Intel Intrinsics Guide</a>. The best way for me to show you what the inner loop looks like at this point would be to write it out:</p>

    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#define             WORD (128/8)</span>
      </pre></div>


<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i<span style="color: #333333">+=</span> IN_GHOST) {

    <span style="color: #888888">//Because we assume the width is a multiple of the size of a SSE register,</span>
    <span style="color: #888888">//we can use aligned loads and stores.</span>
    <span style="color: #008800; font-weight: bold">__m128i</span> <span style="color: #333333">*</span>universe_words <span style="color: #333333">=</span> (<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)universe;
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> padded_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> Y_IN_GHOST) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      } <span style="color: #008800; font-weight: bold">else</span> {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      }
    }

    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;</span> j <span style="color: #333333">+</span> i <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #888888">//Set up a vector of ones</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> ones <span style="color: #333333">=</span> _mm_set_epi8(<span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>,
                                        <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>);
      <span style="color: #888888">//Set up a vector of twos</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> twos <span style="color: #333333">=</span> _mm_slli_epi32(ones, <span style="color: #0000DD; font-weight: bold">1</span>);
      <span style="color: #888888">//Set up a vector of threes</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> threes <span style="color: #333333">=</span> _mm_or_si128(ones, twos);
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> Y_OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> Y_OUT_GHOST; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> X_OUT_GHOST); x <span style="color: #333333">+</span> WORD <span style="color: #333333">&lt;=</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> X_OUT_GHOST; x <span style="color: #333333">+=</span> WORD) {
          <span style="color: #008800; font-weight: bold">__m128i</span> n;
          <span style="color: #008800; font-weight: bold">__m128i</span> alive;
          <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
          <span style="color: #888888">//This is an unaligned load</span>
          n <span style="color: #333333">=</span> _mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u), n);
          <span style="color: #888888">//This is an aligned load</span>
          alive <span style="color: #333333">=</span> _mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>));
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          <span style="color: #888888">//The operation we are performing here is the same, but it looks</span>
          <span style="color: #888888">//very different when written in SIMD instructions</span>
          _mm_store_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
            _mm_or_si128(
            <span style="color: #888888">//We need to and with the ones vector here because the result of</span>
            <span style="color: #888888">//comparison is either 0xFF or 0, and we need 1 or 0.</span>
            _mm_and_si128(ones, _mm_cmpeq_epi8(n, threes)),
            _mm_and_si128(alive, _mm_cmpeq_epi8(n, twos))));
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
  }
</pre></div>
    <p>This code achieves a speedup of x over the reference on the 4096x4096 grid for 256 iterations. Not bad.</p>

    <h2>avx2.c</h2>
    <p><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> instructions are like double-wide SSE instructions. They can hold 256 bits (meaning 32 <code>uint8_t</code>), so we require that the width of the input is a multiple of 32. This code achieves a speedup of x over the reference on the 4096x4096 grid for 256 iterations, but because it is so similar to the SSE version we do not include it.</p>
    <h2>omp.c</h2>
    <p>We have a pretty decent speedup over the reference on a single thread, so why don't we move to multiple threads? <a href="https://en.wikipedia.org/wiki/OpenMP">OpenMP</a> is a library that makes it easy to distribute loop iterations among processes. Here's what it looks like: </p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">    <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp parallel
    {
      <span style="color: #888888">//To avoid race conditions, each thread keeps their own copy of the</span>
      <span style="color: #888888">//universe and new pointers</span>
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_universe <span style="color: #333333">=</span> universe;
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_new <span style="color: #333333">=</span> new;

      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;</span> j <span style="color: #333333">+</span> i <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
        <span style="color: #888888">//We distribute the loop over y, not x, because we want to avoid writing</span>
        <span style="color: #888888">//to the same cache lines</span>
        <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp <span style="color: #008800; font-weight: bold">for</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> Y_OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> Y_OUT_GHOST; y<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> X_OUT_GHOST); x <span style="color: #333333">+</span> WORD <span style="color: #333333">&lt;=</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> X_OUT_GHOST; x <span style="color: #333333">+=</span> WORD) {
            __m256i n;
            __m256i alive;
            <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> my_universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
            n <span style="color: #333333">=</span> _mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            alive <span style="color: #333333">=</span> _mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>));
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            _mm256_store_si256((__m256i<span style="color: #333333">*</span>)(my_new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
              _mm256_or_si256(
              _mm256_and_si256(ones, _mm256_cmpeq_epi8(n, threes)),
              _mm256_and_si256(alive, _mm256_cmpeq_epi8(n, twos))));
          }
        }
        <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> my_universe;
        my_universe <span style="color: #333333">=</span> my_new;
        my_new <span style="color: #333333">=</span> tmp;
      }
      <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp single
      {
        <span style="color: #888888">//Again to avoid race conditions, a single thread (it doesn&#39;t matter</span>
        <span style="color: #888888">//since all the threads have the same copies of everything) writes their</span>
        <span style="color: #888888">//copies of the universe and new pointers to the shared copies for the</span>
        <span style="color: #888888">//next time</span>
        universe <span style="color: #333333">=</span> my_universe;
        new <span style="color: #333333">=</span> my_new;
      }
    }
</pre></div>

    <p>Now we are getting the speedups we deserve! This gets a speedup of x over the reference version on the 4096x4096 grid for 256 iterations.</p>

  </body>
</html>
