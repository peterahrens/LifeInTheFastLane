<!DOCTYPE html>
<!--
 * Copyright (c) 2016, Peter Ahrens
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Los Alamos National Laboratories nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL PETER AHRENS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * LA-CC-17-018
-->
<html>
  <head>
    <title>Life in the fast lane</title>
  </head>
  <body>

    <h1>Life in the fast lane</h1>

    <p>Conway's Game of Life has been an inspiration to computer scientists since it's creation in 1970. Life is a simulation of cells arranged in a two-dimensional grid. Each cell can be in one of two states, alive or dead. I will leave the <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">full explanation</a> of Life to Wikipedia, and only restate here the rules regarding the interactions between cells:</p>

    <ul>
      <li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
      <li>Any live cell with two or three live neighbors lives on to the next generation.</li>
      <li>Any live cell with more than three live neighbors dies, as if by over-population.</li>
      <li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
    </ul>

    <p>Note that in our implementation of Life, like many others, the environment wraps around to the other side at the edges, like in Pac-Man.</p>

    <p>This text serves as an explanation of my process in getting very good performance out of Life. To make this guide representative of many problems in performance optimization for scientific kernels, I have disallowed myself from pursuing algorithmic optimizations (that said, if you haven't seen <a href="https://en.wikipedia.org/wiki/Hashlife">Hashlife</a>, it is worth checking out). All the optimization techniques you see here should be applicable to a wide variety of codes, and will focus on optimizing the naive algorithm for a given architecture. </p>

    <p>I should give anyone reading this guide an important warning before I start. These techniques can make the code go faster, but they increase code complexity by several orders of magnitude and tend to need different tunings for different machines. If someone else has written an optimized version of code that does what you want to do, I would strongly recommend you use that code before trying the techniques you see here. Use optimized libraries, don't write them unless it is your job. </p>

    <h2>reference.c</h2>

    <p>Like many logical simulations, life is fully deterministic. This means that we can determine if our simulation is correct by comparing our output to a reference implementation. The reference implementation we use will also provide a starting point for optimization. The reference implementation I use has been adapted from the <a href="http://rosettacode.org/wiki/Conway's_Game_of_Life#C">RosettaCode</a> C implementation. Rather than expound on the code for ages, I will let you read it yourself. Explanatory comments are included.

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;stdlib.h&gt;</span>

<span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">reference_life</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> height,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>initial,
                          <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> iters) {
  <span style="color: #888888">//&quot;universe&quot; is the current game of life grid. We will store &quot;alive&quot; as a 1</span>
  <span style="color: #888888">//and &quot;dead&quot; as a 0.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>universe <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);

  <span style="color: #888888">//&quot;new&quot; is a scratch array to store the next iteration as it is calculated.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>new <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);

  <span style="color: #888888">//We must load the initial configuration into the universe memory.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
      universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> initial[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
    }
  }

  <span style="color: #888888">//The main loop: a likely target for later optimization.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        <span style="color: #888888">//Here we loop over the neighbors and count how many are alive.</span>
        <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> yy <span style="color: #333333">=</span> y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy <span style="color: #333333">&lt;=</span> y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> xx <span style="color: #333333">=</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx <span style="color: #333333">&lt;=</span> x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx<span style="color: #333333">++</span>) {
            <span style="color: #888888">//This is a redundant way to perform this operation. Since &quot;alive&quot;</span>
            <span style="color: #888888">//is represented as 1 and &quot;dead&quot; is represented as 0, we can just</span>
            <span style="color: #888888">//add universe[...] to n without the conditional branch.</span>
            <span style="color: #008800; font-weight: bold">if</span> (universe[((yy <span style="color: #333333">+</span> height) <span style="color: #333333">%</span> height) <span style="color: #333333">*</span> width
                         <span style="color: #333333">+</span> ((xx <span style="color: #333333">+</span> width) <span style="color: #333333">%</span> width)]) {
              n<span style="color: #333333">++</span>;
            }
          }
        }
        <span style="color: #888888">//This statement is to avoid counting a cell as a neighbor of itself.</span>
        <span style="color: #008800; font-weight: bold">if</span> (universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]) {
          n<span style="color: #333333">--</span>;
        }
        <span style="color: #888888">//This fairly tight logic determines the status of the cell in the next </span>
        <span style="color: #888888">//iteration. We have to store this in a new array to avoid modifying</span>
        <span style="color: #888888">//the original array as we calculate the new one.</span>
        new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]));
      }
    }
    <span style="color: #888888">//These loops copy the new state array into the current state array,</span>
    <span style="color: #888888">//completing an iteration.</span>
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
      }
    }
  }
  free(new);
  <span style="color: #008800; font-weight: bold">return</span> universe;
}
</pre></div>


    <p>As you can see, there are several problems with the reference implementation. It has lots of conditional and arithmetic logic in the inner loop and it copies the entire universe every iteration. However, it is easy to understand, and it is correct (two properties not everyone can say of their code!). We will only be using the reference code to check correctness of our optimized versions and to have something to compare to.


    <h2>bench.c</h2>

    <p>When optimizing code, it is also important to have benchmarking and test code. Having an accurate benchmark that tests a common case for your code gives you the information you need to make optimization decisions. Our benchmark code includes test code as well. Rather than paste the whole file, I'll only include the highlights here.</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">//Return time time of day as a double-precision floating point value.</span>
<span style="color: #333399; font-weight: bold">double</span> <span style="color: #0066BB; font-weight: bold">wall_time</span> (<span style="color: #333399; font-weight: bold">void</span>) {
  <span style="color: #008800; font-weight: bold">struct</span> timeval t;
  <span style="color: #888888">//It is critically important to use an accurate timer. Many common functions</span>
  <span style="color: #888888">//that return the time are not accurate enough for timing code. Since timers</span>
  <span style="color: #888888">//are typically system-specific, research timers for your system.</span>
  <span style="color: #888888">//Surprisingly, omp_get_wtime() is quite good and is available everywhere</span>
  <span style="color: #888888">//there is OpenMP.</span>
  gettimeofday(<span style="color: #333333">&amp;</span>t, <span style="color: #007020">NULL</span>);
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #6600EE; font-weight: bold">1.0</span><span style="color: #333333">*</span>t.tv_sec <span style="color: #333333">+</span> <span style="color: #6600EE; font-weight: bold">1.0e-6</span><span style="color: #333333">*</span>t.tv_usec;
}
</pre></div>


    <p> Note that in our benchmark, <code>TIMEOUT</code> is set to 0.1 seconds</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">double</span> test_time <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>test;

  <span style="color: #888888">//We must run the benchmarking application for a sufficient length of time</span>
  <span style="color: #888888">//to avoid small variations in processing speed. We do this by running an</span>
  <span style="color: #888888">//increasing number of trials until it takes at least TIMEOUT seconds.</span>
  <span style="color: #008800; font-weight: bold">for</span> (trials <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>; test_time <span style="color: #333333">&lt;</span> TIMEOUT; trials <span style="color: #333333">*=</span> <span style="color: #0000DD; font-weight: bold">2</span>) {

    <span style="color: #888888">//Unless you want to measure the cache warm-up time, it is usually a good</span>
    <span style="color: #888888">//idea to run the problem for one iteration first to load the problem</span>
    <span style="color: #888888">//into cache.</span>
    test <span style="color: #333333">=</span> life(height, width, initial, <span style="color: #0000DD; font-weight: bold">1</span>);
    free(test);

    <span style="color: #888888">//Benchmark &quot;trials&quot; runs of life.</span>
    test_time <span style="color: #333333">=</span> <span style="color: #333333">-</span>wall_time();
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> trials <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; <span style="color: #333333">++</span>i){
      test <span style="color: #333333">=</span> life(height, width, initial, iters);
      free(test);
    }
    test <span style="color: #333333">=</span> life(height, width, initial, iters);
    test_time <span style="color: #333333">+=</span> wall_time();
  }
  trials <span style="color: #333333">/=</span> <span style="color: #0000DD; font-weight: bold">2</span>;
  test_time <span style="color: #333333">/=</span> trials;
</pre></div>

    <p>As you can see, writing good benchmark code is more complicated than slapping a timer on both sides of the loop.</p>


    <h2>simple.c</h2>

    Because optimization make code complicated, it is advisable to simplify the code whenever possible. Before we start heavily optimizing the reference implementation, we can fix the glaring flaws in the reference implementation. Here is the new inner loop:

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i <span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> width; x<span style="color: #333333">++</span>) {
        <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> yy <span style="color: #333333">=</span> y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy <span style="color: #333333">&lt;=</span> y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; yy<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> xx <span style="color: #333333">=</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx <span style="color: #333333">&lt;=</span> x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>; xx<span style="color: #333333">++</span>) {
              <span style="color: #888888">//Directly add &quot;universe&quot; values to &quot;n&quot;</span>
              n <span style="color: #333333">+=</span> universe[((yy <span style="color: #333333">+</span> height) <span style="color: #333333">%</span> height) <span style="color: #333333">*</span> width
                            <span style="color: #333333">+</span> ((xx <span style="color: #333333">+</span> width) <span style="color: #333333">%</span> width)];
            }
          }
          n <span style="color: #333333">-=</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x];
          new[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> universe[y <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x]));
      }
    }
    <span style="color: #888888">//Instead of copying &quot;new&quot; into universe every time, just swap the pointers</span>
    <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
    universe <span style="color: #333333">=</span> new;
    new <span style="color: #333333">=</span> tmp;
  }
</pre></div>

    <p>On a 8192x8192 grid for 256 iterations, these optimizations provide a 1.288x speedup over the reference implementation. Not much, be we are just getting started!</p>

    <h2>Environment</h2>
    <p> The compiler you use and the machine you run on are both big factors in how well your code performs. Expecting code optimized for one platform to run well on another is like expecting your friend's shoe to fit your foot. You must optimize <i>for</i> a particular platform. With that in mind, I will show the results from running the command <code>lscpu</code> on my machine.
<pre><code>
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                40
On-line CPU(s) list:   0-39
Thread(s) per core:    2
Core(s) per socket:    10
Socket(s):             2
NUMA node(s):          2
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 63
Model name:            Intel(R) Xeon(R) CPU E5-2660 v3 @ 2.60GHz
Stepping:              2
CPU MHz:               2600.000
BogoMIPS:              5209.96
Virtualization:        VT-x
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              25600K
NUMA node0 CPU(s):     0-9,20-29
NUMA node1 CPU(s):     10-19,30-39
</code></pre>
    <p>Since this chip has 20 CPUs across two <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> domains, so we might need to use a distributed-memory parallel language to take full advantage of the processing power of this chip.</p>
    <p>It is important to quantify the best performance possible, so that we know how much more we can optimize. One possible measurement is our peak performance. To calculate the peak performance in our case, we start by noticing that there are 12 necessary integer operations in our inner loop (we count the comparisons to 2 and 3, and we don't count the redundant add and subtract of the cell value itself). We assume that we can do one instruction per clock cycle. The processor runs at 2.6*10<sup>9</sup> clock cycles per second, and this machine supports AVX2, so we can operate on 32 8-bit sized integers at once, and there are 20 cores. Therefore, on average we can advance one cell one iteration in 7.2*10<sup>-12</sup> seconds. Therefore, the theoretical peak time to compute our 8192x8192 test problem over 256 iterations in 1.24*10<sup>-1</sup> seconds. Keep this number in mind!</p>

    <p>Another important environmental factor in the performance of your code is what compiler (and compiler flags) you are using. For the record, I am using gcc version 4.9.3 with the compiler flags "-O3 -march=native". Really dig in to your compiler's documentation, because some flags can speed up your code and you don't have to do any work!</p>

    <h2>padding.c</h2>

    <p>Finally, we are ready to implement our first real optimization! Typically, codes spend a lot of their time in the inner loop. Our inner loop includes complicated modular arithmetic on indices and a doubly-nested for loop. Let's fix this! We can do this using a technique called "padding". In short, instead of looking to the other side of the universe to wrap around in the inner loop, we will allocate an array with extra cells on all sides ("ghost cells") and fill these cells with values from the other side of the array. That way, when the inner loop accesses beyond the the edges of the universe, it looks like the universe is wrapping around.</p>

    <p>Each time we perform an iteration, we lose the outer layer of ghost cells, since they are no longer valid (we did not calculate anything on the outermost layer of the array). To avoid copying with every iteration, we can pad with multiple ghost cell layers at once, and then run several iterations before copying again.</p>

    <p>The code is significantly more complicated now. If you don't understand everything at first, that's okay. Try to get the main ideas from the code, and understand the comments. Note that this code assumes that <code>width</code> is a multiple of <code>sizeof(unsigned)</code>.</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;stdint.h&gt;</span>


<span style="color: #557799">#define             WORD sizeof(unsigned)</span>
<span style="color: #888888">//OUT_GHOST is the width of the valid ghost cells after copying IN_GHOST ghost</span>
<span style="color: #888888">//cell values to the border and then executing one iteration. The kernel will</span>
<span style="color: #888888">//copy IN_GHOST ghost cells, then run IN_GHOST iterations before copying ghost</span>
<span style="color: #888888">//cells again. OUT_GHOST can be any value greater than or equal to 0.</span>
<span style="color: #557799">#define        OUT_GHOST 0</span>
<span style="color: #557799">#define         IN_GHOST (OUT_GHOST + 1)</span>
<span style="color: #557799">#define       X_IN_GHOST ((OUT_GHOST/WORD + 1) * WORD)</span>
<span style="color: #557799">#define       Y_IN_GHOST IN_GHOST</span>
<span style="color: #557799">#define X_IN_GHOST_WORDS (X_IN_GHOST/WORD)</span>

<span style="color: #888888">//There are platform specific aligned malloc implementations, but it is</span>
<span style="color: #888888">//instructive to see one written out explicitly. Allocates memory, then rounds</span>
<span style="color: #888888">//it to a multiple of WORD. Stores a pointer to the original memory to free it.</span>
<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">aligned_malloc</span>(<span style="color: #333399; font-weight: bold">int</span> size) {
    <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">*</span>mem <span style="color: #333333">=</span> malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> size <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>);
    <span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">**</span>ptr <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)(((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(mem <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)) <span style="color: #333333">&amp;</span> <span style="color: #333333">~</span>((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)));
    ptr[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> mem;
    <span style="color: #008800; font-weight: bold">return</span> ptr;
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">aligned_free</span>(<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span>ptr) {
    free(((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)ptr)[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>]);
}

<span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">life</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> height,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span> <span style="color: #008800; font-weight: bold">const</span> initial,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> iters) {
  <span style="color: #888888">//Padding makes things ridiculously complicated. These constant values</span>
  <span style="color: #888888">//make life a little easier.</span>
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_height <span style="color: #333333">=</span> height <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> Y_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_width <span style="color: #333333">=</span> width <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> X_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width_words <span style="color: #333333">=</span> width<span style="color: #333333">/</span>WORD;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> padded_width_words <span style="color: #333333">=</span> padded_width<span style="color: #333333">/</span>WORD;

  <span style="color: #888888">//Oh! The careful reader will notice that I am allocating an array of</span>
  <span style="color: #888888">//byte-size ints! In addition to preparing us for vectorization later, this</span>
  <span style="color: #888888">//also reduces memory traffic.</span>
  <span style="color: #888888">//Also, this memory is aligned. Aligned memory access is typically faster</span>
  <span style="color: #888888">//that unaligned. To keep the memory aligned on each row, we have to pad</span>
  <span style="color: #888888">//to a multiple of the word size. We also assume the input matrix has a width</span>
  <span style="color: #888888">//that is a multiple of the word size.</span>
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>universe <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(padded_height <span style="color: #333333">*</span> padded_width);
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>new <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(padded_height <span style="color: #333333">*</span> padded_width);

  <span style="color: #888888">//Pack unsigned into the padded working array of uint8_t.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST; x<span style="color: #333333">++</span>) {
      universe[(y <span style="color: #333333">*</span> padded_width) <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> initial[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST];
    }
  }

  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i <span style="color: #333333">+=</span> IN_GHOST) {

    <span style="color: #888888">//Copy the ghost cells once every IN_GHOST iterations. I have not only</span>
    <span style="color: #888888">//simplified much of the logic (no more mod operations!), I have also</span>
    <span style="color: #888888">//reduced the number of instructions necessary to copy by casting the</span>
    <span style="color: #888888">//uint8_t array to unsigned and working with these larger values of a size</span>
    <span style="color: #888888">//the system is used to working with.</span>
    <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>universe_words <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)universe;
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> padded_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> Y_IN_GHOST) {
        <span style="color: #888888">//Top left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Top middle</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x];
        }
        <span style="color: #888888">//Top right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST) {
        <span style="color: #888888">//Middle left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Middle right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      } <span style="color: #008800; font-weight: bold">else</span> {
        <span style="color: #888888">//Bottom left</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words];
        }
        <span style="color: #888888">//Bottom middle</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x];
        }
        <span style="color: #888888">//Bottom right</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          universe_words[y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> universe_words[(y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words];
        }
      }
    }

    <span style="color: #888888">//The valid ghost zone shrinks by one with each iteration.</span>
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;&amp;</span> i <span style="color: #333333">+</span> j <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; x<span style="color: #333333">++</span>) {
          <span style="color: #888888">//The inner loop gets much simpler when you pad the array, doesn&#39;t it?</span>
          <span style="color: #888888">//This is the main reason people pad their arrays before computation.</span>
          <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
          <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
          <span style="color: #888888">//Note that constant offsets into memory are faster.</span>
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          <span style="color: #333399; font-weight: bold">unsigned</span> alive <span style="color: #333333">=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
          n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
          new[y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> alive));
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
  }

  <span style="color: #888888">//Unpack uint8_t into output array of unsigned.</span>
  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>out <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST; x<span style="color: #333333">++</span>) {
      out[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST] <span style="color: #333333">=</span> universe[(y <span style="color: #333333">*</span> padded_width) <span style="color: #333333">+</span> x];
    }
  }

  aligned_free(new);
  aligned_free(universe);
  <span style="color: #008800; font-weight: bold">return</span> out;
}
</pre></div>

    <p>On a 8192x8192 grid for 256 iterations, this code achieves our first significant speedup of 5.201x over the reference version!</p>

    <h2>blocked.c</h2>
    <p>Our code tends to progress linearly across each row, accessing only the rows above and below it. Life needs to access each element nine times (eight times while counting among neighbors, and once to calculate the cell itself). As computation proceeds row by row, these accesses occur in groups of three (once group for each row), and if three rows of the matrix can fit in L1 cache, then the data is only loaded once from cache per iteration. However, if our computation accessed the data many more times per iteration, it might benefit from a technique called blocking. </p>
    <p>Blocking is the practice of grouping the memory accesses together to keep the data in the highest level of the memory hierarchy possible. Register blocking is the reuse of data while it is still in the registers. Register blocking occurs in the inner loop of your code when you reuse values you have loaded from memory instead of loading them multiple times. Cache blocking is the reuse of data while it resides in cache. Cache blocking can be achieved by restructuring the ordering of loops so that nearby values are accessed soon after each other. Typically, you want a cache block to take up a sizable portion of your L1 cache. </p>
    <p>Although it doesn't help much in our case (the loop logic overhead exceeds memory benefits), we show an example of how to restructure the padded inner loop for cache blocking:</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#define          X_BLOCK WORD * 256</span>
<span style="color: #557799">#define          Y_BLOCK 256</span>
</pre></div>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;&amp;</span> i <span style="color: #333333">+</span> j <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #888888">//Now the outer loops progress block by block.</span>
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; y <span style="color: #333333">+=</span> Y_BLOCK) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> OUT_GHOST); x <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; x <span style="color: #333333">+=</span> X_BLOCK) {
          <span style="color: #888888">//The inner loops progress one by one.</span>
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> yy <span style="color: #333333">=</span> y; yy <span style="color: #333333">&lt;</span> y <span style="color: #333333">+</span> Y_BLOCK <span style="color: #333333">&amp;&amp;</span> yy <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; yy<span style="color: #333333">++</span>) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> xx <span style="color: #333333">=</span> x; xx <span style="color: #333333">&lt;</span> x <span style="color: #333333">+</span> X_BLOCK <span style="color: #333333">&amp;&amp;</span> xx <span style="color: #333333">&lt;</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> OUT_GHOST; xx<span style="color: #333333">++</span>) {
              <span style="color: #333399; font-weight: bold">unsigned</span> n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
              <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (yy <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> xx <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              u <span style="color: #333333">+=</span> padded_width;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              <span style="color: #333399; font-weight: bold">unsigned</span> alive <span style="color: #333333">=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              u <span style="color: #333333">+=</span> padded_width;
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">0</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">1</span>];
              n <span style="color: #333333">+=</span> u[<span style="color: #0000DD; font-weight: bold">2</span>];
              new[yy <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> xx] <span style="color: #333333">=</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #333333">||</span> (n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">&amp;&amp;</span> alive));
            }
          }
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
</pre></div>

    <h2>sse2.c</h2>
    <p>Now, we will cram more operations into the inner loop using vectorization. This is our first form of explicit parallelism, at the instruction level. Intel's <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> vector intrinsics are 128 bits wide, so we can cram 16 <code>uint8_t</code> types into a single vector register, and operate on them all at once. To keep the code nice, we require that the width of the input is a multiple of 16. Specifically, we are using SSE2. A good resource for Intel vector intrinsics is the <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#">Intel Intrinsics Guide</a>. The best way for me to show you what the inner loop looks like at this point would be to write it out:</p>

    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#define             WORD (128/8)</span>
      </pre></div>


<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i<span style="color: #333333">+=</span> IN_GHOST) {

    <span style="color: #888888">//Because we assume the width is a multiple of the size of a SSE register,</span>
    <span style="color: #888888">//we can use aligned loads and stores.</span>
    <span style="color: #008800; font-weight: bold">__m128i</span> <span style="color: #333333">*</span>universe_words <span style="color: #333333">=</span> (<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)universe;
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> padded_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> Y_IN_GHOST) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> (y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      } <span style="color: #008800; font-weight: bold">else</span> {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> width_words));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST_WORDS; x <span style="color: #333333">&lt;</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x));
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS ; x <span style="color: #333333">&lt;</span> padded_width_words; x<span style="color: #333333">++</span>) {
          _mm_store_si128(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x,
            _mm_load_si128(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> height) <span style="color: #333333">*</span> padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">-</span> width_words));
        }
      }
    }

    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;</span> j <span style="color: #333333">+</span> i <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
      <span style="color: #888888">//Set up a vector of ones</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> ones <span style="color: #333333">=</span> _mm_set_epi8(<span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>,
                                        <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>);
      <span style="color: #888888">//Set up a vector of twos</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> twos <span style="color: #333333">=</span> _mm_slli_epi32(ones, <span style="color: #0000DD; font-weight: bold">1</span>);
      <span style="color: #888888">//Set up a vector of threes</span>
      <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">__m128i</span> threes <span style="color: #333333">=</span> _mm_or_si128(ones, twos);
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> Y_OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> Y_OUT_GHOST; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> X_OUT_GHOST); x <span style="color: #333333">+</span> WORD <span style="color: #333333">&lt;=</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> X_OUT_GHOST; x <span style="color: #333333">+=</span> WORD) {
          <span style="color: #008800; font-weight: bold">__m128i</span> n;
          <span style="color: #008800; font-weight: bold">__m128i</span> alive;
          <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
          <span style="color: #888888">//This is an unaligned load</span>
          n <span style="color: #333333">=</span> _mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u), n);
          <span style="color: #888888">//This is an aligned load</span>
          alive <span style="color: #333333">=</span> _mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>));
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          u <span style="color: #333333">+=</span> padded_width;
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)u), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_load_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
          n <span style="color: #333333">=</span> _mm_add_epi8(_mm_lddqu_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
          <span style="color: #888888">//The operation we are performing here is the same, but it looks</span>
          <span style="color: #888888">//very different when written in SIMD instructions</span>
          _mm_store_si128((<span style="color: #008800; font-weight: bold">__m128i</span><span style="color: #333333">*</span>)(new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
            _mm_or_si128(
            <span style="color: #888888">//We need to and with the ones vector here because the result of</span>
            <span style="color: #888888">//comparison is either 0xFF or 0, and we need 1 or 0.</span>
            _mm_and_si128(ones, _mm_cmpeq_epi8(n, threes)),
            _mm_and_si128(alive, _mm_cmpeq_epi8(n, twos))));
        }
      }
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> universe;
      universe <span style="color: #333333">=</span> new;
      new <span style="color: #333333">=</span> tmp;
    }
  }
</pre></div>
    <p>This code achieves a speedup of 58.06x over the reference on the 8192x8192 grid for 256 iterations. Not bad.</p>

    <h2>avx2.c</h2>

    <p><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> instructions are like double-wide SSE instructions. They can hold 256 bits (meaning 32 <code>uint8_t</code>), so we require that the width of the input is a multiple of 32. This code achieves a speedup of 72.42x over the reference on the 8192x8192 grid for 256 iterations, but because it is so similar to the SSE version we do not include it. Note that this is 66.87% of the single CPU peak. </p>

    <h2>streaming.c</h2>

    <p>Because life performs only 12 operations per byte loaded (and an AVX instruction can operate on 32 bytes simultaneously), our simulation has low arithmetic intensity and would likely benefit from memory optimizations. Therefore, I put a <a href="https://software.intel.com/sites/default/files/article/326703/streaming-stores-2.pdf">streaming store</a> in the inner loop. A streaming store writes to memory without first reading the value into cache (leaving the cache to do more useful things. Since we know we do not need to read the value in the <code>new</code> array, this is the perfect operation for us. The last line of our inner loop moves from this:

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">          _mm256_store_si256((__m256i<span style="color: #333333">*</span>)(new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
            _mm256_or_si256(
            _mm256_and_si256(ones, _mm256_cmpeq_epi8(n, threes)),
            _mm256_and_si256(alive, _mm256_cmpeq_epi8(n, twos))));
</pre></div>

    To this:

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">          _mm256_stream_si256((__m256i<span style="color: #333333">*</span>)(new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
            _mm256_or_si256(
            _mm256_and_si256(ones, _mm256_cmpeq_epi8(n, threes)),
            _mm256_and_si256(alive, _mm256_cmpeq_epi8(n, twos))));
</pre></div>

    And our code now achieves a speedup of 86.44x over the reference on the 8192x8192 grid for 256 iterations. We are now running at 79.82% of the single CPU peak. Typically, once you are running at ~80% of peak on a single processor, getting additional speedups will yield quickly diminishing returns. It's time to go parallel!</p>

    <h2>omp.c</h2>

    <p>We have a pretty decent speedup over the reference on a single thread, so why don't we move to multiple threads? <a href="https://en.wikipedia.org/wiki/OpenMP">OpenMP</a> is a library that makes it easy to distribute loop iterations among processes. Here's what it looks like: </p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">    <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp parallel
    {
      <span style="color: #888888">//To avoid race conditions, each thread keeps their own copy of the</span>
      <span style="color: #888888">//universe and new pointers</span>
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_universe <span style="color: #333333">=</span> universe;
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_new <span style="color: #333333">=</span> new;

      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;</span> j <span style="color: #333333">+</span> i <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
        <span style="color: #888888">//We distribute the loop over y, not x, because we want to avoid writing</span>
        <span style="color: #888888">//to the same cache lines</span>
        <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp <span style="color: #008800; font-weight: bold">for</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> Y_OUT_GHOST); y <span style="color: #333333">&lt;</span> height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> Y_OUT_GHOST; y<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> X_OUT_GHOST); x <span style="color: #333333">+</span> WORD <span style="color: #333333">&lt;=</span> width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> X_OUT_GHOST; x <span style="color: #333333">+=</span> WORD) {
            __m256i n;
            __m256i alive;
            <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> my_universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
            n <span style="color: #333333">=</span> _mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            alive <span style="color: #333333">=</span> _mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>));
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            _mm256_stream_si256((__m256i<span style="color: #333333">*</span>)(my_new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> padded_width <span style="color: #333333">+</span> x),
              _mm256_or_si256(
              _mm256_and_si256(ones, _mm256_cmpeq_epi8(n, threes)),
              _mm256_and_si256(alive, _mm256_cmpeq_epi8(n, twos))));
          }
        }
        <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> my_universe;
        my_universe <span style="color: #333333">=</span> my_new;
        my_new <span style="color: #333333">=</span> tmp;
      }
      <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp single
      {
        <span style="color: #888888">//Again to avoid race conditions, a single thread (it doesn&#39;t matter</span>
        <span style="color: #888888">//since all the threads have the same copies of everything) writes their</span>
        <span style="color: #888888">//copies of the universe and new pointers to the shared copies for the</span>
        <span style="color: #888888">//next time</span>
        universe <span style="color: #333333">=</span> my_universe;
        new <span style="color: #333333">=</span> my_new;
      }
    }
  }
</pre></div>

    <p>Now we are getting the speedups we deserve! This gets a speedup of 375.6x over the reference version on the 8192x8192 grid for 256 iterations, and we are only using 10 of the available 40 processors on this CPU! Keep in mind that we are currently only running at 17.34% of our theoretical peak processing rate!</p>
    <p>Our OpenMP code does not scale beyond the NUMA node, however. From the following graph, we see that our code gets no real performance gain beyond 10 threads.</p>
    <img src=omp_plot.png></img>

    <h2>mpi.c</h2>

    <p>Because this machine has two <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> nodes, our problem would likely benefit from having memory local to each NUMA node. We can do this using <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a>, and binding processes to physical CPUs. This way, each NUMA node has a separate MPI task with it's own memory, instead of OpenMP. Each MPI task can then run OpenMP on the NUMA node.</p>

    <p>Our MPI program makes several simplifications, assuming that the number of processors is a perfect square, that the height is divisible by the square root of the number of processors, and that the width is divisible by the word size times the square root of the number of processes.</p>

    <p>I would like to point out that the MPI code is more that 10 times longer than our reference code. I will list the code itself, but the general idea is that each process is part of a grid, and instead of copying the ghost cells like we did in previous versions, we will send them to our neighbors. The code follows:</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;stdlib.h&gt;</span>
<span style="color: #557799">#include &lt;stdint.h&gt;</span>
<span style="color: #557799">#include &lt;immintrin.h&gt;</span>
<span style="color: #557799">#include &lt;math.h&gt;</span>
<span style="color: #557799">#include &lt;omp.h&gt;</span>
<span style="color: #557799">#include &lt;mpi.h&gt;</span>

<span style="color: #557799">#define             WORD (256/8)</span>
<span style="color: #557799">#define        OUT_GHOST 7</span>
<span style="color: #557799">#define      X_OUT_GHOST (((OUT_GHOST - 1)/WORD + 1) * WORD)</span>
<span style="color: #557799">#define      Y_OUT_GHOST OUT_GHOST</span>
<span style="color: #557799">#define         IN_GHOST (OUT_GHOST + 1)</span>
<span style="color: #557799">#define       X_IN_GHOST ((OUT_GHOST/WORD + 1) * WORD)</span>
<span style="color: #557799">#define       Y_IN_GHOST IN_GHOST</span>
<span style="color: #557799">#define X_IN_GHOST_WORDS (X_IN_GHOST/WORD)</span>

<span style="color: #888888">//Here are the tags we will use to distinguish where the data is coming from</span>
<span style="color: #888888">//and going to. Notice that the top left corner is sent to the bottom right</span>
<span style="color: #888888">//corner of the top left neighbor.</span>
<span style="color: #557799">#define     TOP_LEFT_SEND 0</span>
<span style="color: #557799">#define BOTTOM_RIGHT_RECV 0</span>
<span style="color: #557799">#define          TOP_SEND 1</span>
<span style="color: #557799">#define       BOTTOM_RECV 1</span>
<span style="color: #557799">#define    TOP_RIGHT_SEND 2</span>
<span style="color: #557799">#define  BOTTOM_LEFT_RECV 2</span>
<span style="color: #557799">#define        RIGHT_SEND 3</span>
<span style="color: #557799">#define         LEFT_RECV 3</span>
<span style="color: #557799">#define BOTTOM_RIGHT_SEND 4</span>
<span style="color: #557799">#define     TOP_LEFT_RECV 4</span>
<span style="color: #557799">#define       BOTTOM_SEND 5</span>
<span style="color: #557799">#define          TOP_RECV 5</span>
<span style="color: #557799">#define  BOTTOM_LEFT_SEND 6</span>
<span style="color: #557799">#define    TOP_RIGHT_RECV 6</span>
<span style="color: #557799">#define         LEFT_SEND 7</span>
<span style="color: #557799">#define        RIGHT_RECV 7</span>

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">aligned_malloc</span>(<span style="color: #333399; font-weight: bold">int</span> size) {
    <span style="color: #333399; font-weight: bold">char</span> <span style="color: #333333">*</span>mem <span style="color: #333333">=</span> malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> size <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>);
    <span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">**</span>ptr <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)(((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(mem <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>) <span style="color: #333333">+</span> WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)) <span style="color: #333333">&amp;</span> <span style="color: #333333">~</span>((<span style="color: #333399; font-weight: bold">uintptr_t</span>)(WORD <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>)));
    ptr[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> mem;
    <span style="color: #008800; font-weight: bold">return</span> ptr;
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">aligned_free</span>(<span style="color: #333399; font-weight: bold">void</span> <span style="color: #333333">*</span>ptr) {
    free(((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">**</span>)ptr)[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>]);
}

<span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span><span style="color: #0066BB; font-weight: bold">life</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> height,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> width,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span> <span style="color: #008800; font-weight: bold">const</span> initial,
                <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> iters) {
  <span style="color: #333399; font-weight: bold">int</span> rank;
  <span style="color: #333399; font-weight: bold">int</span> size;

  MPI_Comm_rank(MPI_COMM_WORLD, <span style="color: #333333">&amp;</span>rank);
  MPI_Comm_size(MPI_COMM_WORLD, <span style="color: #333333">&amp;</span>size);

  <span style="color: #888888">//We will be arranging our processes in a grid. We are assuming that the</span>
  <span style="color: #888888">//problem width is divisible by the square root of the number of processors</span>
  <span style="color: #888888">//times the width of a word, and that the height is divisible by the</span>
  <span style="color: #888888">//square root of the number of processes, and the number of processes</span>
  <span style="color: #888888">//is a perfect square</span>
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> side <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">int</span>)sqrt((<span style="color: #333399; font-weight: bold">double</span>)size);
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_height <span style="color: #333333">=</span> height<span style="color: #333333">/</span>side;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_width <span style="color: #333333">=</span> width<span style="color: #333333">/</span>side;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_y <span style="color: #333333">=</span> (rank <span style="color: #333333">/</span> side);
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_x <span style="color: #333333">=</span> (rank <span style="color: #333333">%</span> side);

  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_padded_height <span style="color: #333333">=</span> my_height <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> Y_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_padded_width <span style="color: #333333">=</span> my_width <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">*</span> X_IN_GHOST;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_width_words <span style="color: #333333">=</span> my_width<span style="color: #333333">/</span>WORD;
  <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> my_padded_width_words <span style="color: #333333">=</span> my_padded_width<span style="color: #333333">/</span>WORD;
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>universe <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(my_padded_height <span style="color: #333333">*</span> my_padded_width);
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>new <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(my_padded_height <span style="color: #333333">*</span> my_padded_width);

  <span style="color: #008800; font-weight: bold">const</span> __m256i ones <span style="color: #333333">=</span> _mm256_set_epi8(<span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>,
                                       <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>,
                                       <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>,
                                       <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">1</span>);
  <span style="color: #008800; font-weight: bold">const</span> __m256i twos <span style="color: #333333">=</span> _mm256_slli_epi32(ones, <span style="color: #0000DD; font-weight: bold">1</span>);
  <span style="color: #008800; font-weight: bold">const</span> __m256i threes <span style="color: #333333">=</span> _mm256_or_si256(ones, twos);

  <span style="color: #888888">//We start by sending the data to all the processes. The data is first</span>
  <span style="color: #888888">//partitioned into a grid of rectangles (one for each processor).</span>
  <span style="color: #888888">//Here we first break up the initial data into rectangles.</span>
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>scatter_buffer_send;
  <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>scatter_buffer_recv <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(my_height <span style="color: #333333">*</span> my_width);
  <span style="color: #008800; font-weight: bold">if</span> (rank <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
    scatter_buffer_send <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">uint8_t</span><span style="color: #333333">*</span>)aligned_malloc(height <span style="color: #333333">*</span> width);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> their_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; their_y <span style="color: #333333">&lt;</span> side; their_y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> their_x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; their_x <span style="color: #333333">&lt;</span> side; their_x<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width; x<span style="color: #333333">++</span>) {
            scatter_buffer_send[(their_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> their_x) <span style="color: #333333">*</span> (my_width <span style="color: #333333">*</span> my_height) <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span>
              initial[(their_y <span style="color: #333333">*</span> my_height <span style="color: #333333">+</span> y) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> their_x <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x];
          }
        }
      }
    }
  }
  MPI_Scatter((<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)scatter_buffer_send,
              my_height <span style="color: #333333">*</span> my_width,
              MPI_UNSIGNED_CHAR,
              (<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)scatter_buffer_recv,
              my_height <span style="color: #333333">*</span> my_width,
              MPI_UNSIGNED_CHAR,
              <span style="color: #0000DD; font-weight: bold">0</span>,
              MPI_COMM_WORLD);
  <span style="color: #888888">//Now that the data has been scattered, we copy our personal rectangle into</span>
  <span style="color: #888888">//our local universe.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> Y_IN_GHOST <span style="color: #333333">+</span> my_height; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> X_IN_GHOST <span style="color: #333333">+</span> my_width; x<span style="color: #333333">++</span>) {

      universe[(y <span style="color: #333333">*</span> my_padded_width) <span style="color: #333333">+</span> x] <span style="color: #333333">=</span> scatter_buffer_recv[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST];
    }
  }

  <span style="color: #888888">//There&#39;s a bunch of send buffers aren&#39;t there?</span>
  __m256i     <span style="color: #333333">*</span>ghost_buffer_top_left_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i          <span style="color: #333333">*</span>ghost_buffer_top_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(  my_width <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i    <span style="color: #333333">*</span>ghost_buffer_top_right_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i        <span style="color: #333333">*</span>ghost_buffer_right_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> my_height );
  __m256i <span style="color: #333333">*</span>ghost_buffer_bottom_right_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i       <span style="color: #333333">*</span>ghost_buffer_bottom_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(  my_width <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i  <span style="color: #333333">*</span>ghost_buffer_bottom_left_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i         <span style="color: #333333">*</span>ghost_buffer_left_send <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> my_height );

  __m256i <span style="color: #333333">*</span>ghost_buffer_bottom_right_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i       <span style="color: #333333">*</span>ghost_buffer_bottom_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(  my_width <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i  <span style="color: #333333">*</span>ghost_buffer_bottom_left_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i         <span style="color: #333333">*</span>ghost_buffer_left_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> my_height );
  __m256i     <span style="color: #333333">*</span>ghost_buffer_top_left_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i          <span style="color: #333333">*</span>ghost_buffer_top_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(  my_width <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i    <span style="color: #333333">*</span>ghost_buffer_top_right_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST);
  __m256i        <span style="color: #333333">*</span>ghost_buffer_right_recv <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)aligned_malloc(X_IN_GHOST <span style="color: #333333">*</span> my_height );

  MPI_Request top_left_req;
  MPI_Request top_req;
  MPI_Request top_right_req;
  MPI_Request right_req;
  MPI_Request bottom_right_req;
  MPI_Request bottom_req;
  MPI_Request bottom_left_req;
  MPI_Request left_req;

  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> iters; i<span style="color: #333333">+=</span> IN_GHOST) {
    __m256i <span style="color: #333333">*</span>universe_words <span style="color: #333333">=</span> (__m256i<span style="color: #333333">*</span>)universe;

    <span style="color: #888888">//Here are all of the sends to our neighbors in every cardinal direction.</span>
    <span style="color: #888888">//The sends are nonblocking, so that we can move right on to the next send</span>
    <span style="color: #888888">//without waiting for our neighbors to receive.</span>
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(ghost_buffer_top_left_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
          _mm256_load_si256(universe_words <span style="color: #333333">+</span> (Y_IN_GHOST <span style="color: #333333">+</span> y) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Isend(ghost_buffer_top_left_send,
              X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              TOP_LEFT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>top_left_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width_words; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(ghost_buffer_top_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width_words <span style="color: #333333">+</span> x,
          _mm256_load_si256(universe_words <span style="color: #333333">+</span> (Y_IN_GHOST <span style="color: #333333">+</span> y) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Isend(ghost_buffer_top_send,
              my_width <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> my_x,
              TOP_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>top_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(ghost_buffer_top_right_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
          _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> my_width_words));
      }
    }
    MPI_Isend(ghost_buffer_top_right_send,
              X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              TOP_RIGHT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>top_right_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm256_store_si256(ghost_buffer_right_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
            _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> my_width_words));
        }
    }
    MPI_Isend(ghost_buffer_right_send,
              X_IN_GHOST <span style="color: #333333">*</span> my_height,
              MPI_UNSIGNED_CHAR,
              my_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              RIGHT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>right_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm256_store_si256(ghost_buffer_bottom_right_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
            _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> my_width_words));
        }
    }
    MPI_Isend(ghost_buffer_bottom_right_send,
              X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              BOTTOM_RIGHT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>bottom_right_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width_words; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(ghost_buffer_bottom_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width_words <span style="color: #333333">+</span> x,
          _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS));
      }
    }
    MPI_Isend(ghost_buffer_bottom_send,
              my_width <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> my_x,
              BOTTOM_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>bottom_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(ghost_buffer_bottom_left_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
          _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS));
      }
    }
    MPI_Isend(ghost_buffer_bottom_left_send,
              X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
              MPI_UNSIGNED_CHAR,
              ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              BOTTOM_LEFT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>bottom_left_req);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
          _mm256_store_si256(ghost_buffer_left_send <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x,
            _mm256_load_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS));
        }
    }
    MPI_Isend(ghost_buffer_left_send,
              X_IN_GHOST <span style="color: #333333">*</span> my_height,
              MPI_UNSIGNED_CHAR,
              my_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
              LEFT_SEND,
              MPI_COMM_WORLD,
              <span style="color: #333333">&amp;</span>left_req);

    <span style="color: #888888">//Now we receive ghost zones from all of our neighbors. Since we need to</span>
    <span style="color: #888888">//process our received data immediately, the received data is blocking.</span>
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_bottom_right_recv,
             X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             BOTTOM_RIGHT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> my_width_words,
          _mm256_load_si256(ghost_buffer_bottom_right_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_bottom_recv,
             my_width <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> my_x,
             BOTTOM_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width_words; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS,
          _mm256_load_si256(ghost_buffer_bottom_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width_words <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_bottom_left_recv,
             X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             BOTTOM_LEFT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> my_height) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x,
          _mm256_load_si256(ghost_buffer_bottom_left_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_left_recv,
             X_IN_GHOST <span style="color: #333333">*</span> my_height,
             MPI_UNSIGNED_CHAR,
             my_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             LEFT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x,
          _mm256_load_si256(ghost_buffer_left_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_top_left_recv,
             X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             TOP_LEFT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x,
          _mm256_load_si256(ghost_buffer_top_left_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_top_recv,
             my_width <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> my_x,
             TOP_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width_words; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS,
          _mm256_load_si256(ghost_buffer_top_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width_words <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_top_right_recv,
             X_IN_GHOST <span style="color: #333333">*</span> Y_IN_GHOST,
             MPI_UNSIGNED_CHAR,
             ((my_y <span style="color: #333333">+</span> side <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side) <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             TOP_RIGHT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> Y_IN_GHOST; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> my_width_words,
          _mm256_load_si256(ghost_buffer_top_right_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }
    MPI_Recv((<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)ghost_buffer_right_recv,
             X_IN_GHOST <span style="color: #333333">*</span> my_height,
             MPI_UNSIGNED_CHAR,
             my_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> ((my_x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">%</span> side),
             RIGHT_RECV,
             MPI_COMM_WORLD,
             MPI_STATUS_IGNORE);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> X_IN_GHOST_WORDS; x<span style="color: #333333">++</span>) {
        _mm256_store_si256(universe_words <span style="color: #333333">+</span> (y <span style="color: #333333">+</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_padded_width_words <span style="color: #333333">+</span> x <span style="color: #333333">+</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> my_width_words,
          _mm256_load_si256(ghost_buffer_right_recv <span style="color: #333333">+</span> y <span style="color: #333333">*</span> X_IN_GHOST_WORDS <span style="color: #333333">+</span> x));
      }
    }

    <span style="color: #888888">//The inner loop is the same.</span>
    <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp parallel
    {
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_universe <span style="color: #333333">=</span> universe;
      <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>my_new <span style="color: #333333">=</span> new;

      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> IN_GHOST <span style="color: #333333">&amp;</span> j <span style="color: #333333">+</span> i <span style="color: #333333">&lt;</span> iters; j<span style="color: #333333">++</span>) {
        <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp <span style="color: #008800; font-weight: bold">for</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> (Y_IN_GHOST <span style="color: #333333">-</span> Y_OUT_GHOST); y <span style="color: #333333">&lt;</span> my_height <span style="color: #333333">+</span> Y_IN_GHOST <span style="color: #333333">+</span> Y_OUT_GHOST; y<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> (X_IN_GHOST <span style="color: #333333">-</span> X_OUT_GHOST); x <span style="color: #333333">+</span> WORD <span style="color: #333333">&lt;=</span> my_width <span style="color: #333333">+</span> X_IN_GHOST <span style="color: #333333">+</span> X_OUT_GHOST; x <span style="color: #333333">+=</span> WORD) {
            __m256i n;
            __m256i alive;
            <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>u <span style="color: #333333">=</span> my_universe <span style="color: #333333">+</span> (y <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>) <span style="color: #333333">*</span> my_padded_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>;
            n <span style="color: #333333">=</span> _mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> my_padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            alive <span style="color: #333333">=</span> _mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>));
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            u <span style="color: #333333">+=</span> my_padded_width;
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)u), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_load_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>)), n);
            n <span style="color: #333333">=</span> _mm256_add_epi8(_mm256_lddqu_si256((__m256i<span style="color: #333333">*</span>)(u <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span>)), n);
            _mm256_stream_si256((__m256i<span style="color: #333333">*</span>)(my_new <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_padded_width <span style="color: #333333">+</span> x),
              _mm256_or_si256(
              _mm256_and_si256(ones, _mm256_cmpeq_epi8(n, threes)),
              _mm256_and_si256(alive, _mm256_cmpeq_epi8(n, twos))));
          }
        }
        <span style="color: #333399; font-weight: bold">uint8_t</span> <span style="color: #333333">*</span>tmp <span style="color: #333333">=</span> my_universe;
        my_universe <span style="color: #333333">=</span> my_new;
        my_new <span style="color: #333333">=</span> tmp;
      }
      <span style="color: #FF0000; background-color: #FFAAAA">#</span>pragma omp single
      {
        universe <span style="color: #333333">=</span> my_universe;
        new <span style="color: #333333">=</span> my_new;
      }
    }

    <span style="color: #888888">//Before we start another iteration and start sending again, let&#39;s make sure</span>
    <span style="color: #888888">//that everyone has received our messages.</span>
    MPI_Wait(<span style="color: #333333">&amp;</span>top_left_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>top_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>top_right_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>right_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>bottom_right_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>bottom_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>bottom_left_req, MPI_STATUS_IGNORE);
    MPI_Wait(<span style="color: #333333">&amp;</span>left_req, MPI_STATUS_IGNORE);
  }

  <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333333">*</span>out <span style="color: #333333">=</span> <span style="color: #007020">NULL</span>;
  <span style="color: #888888">//This part is very similar to the Scatter. We now have all of the final</span>
  <span style="color: #888888">//configurations, and need to send them to the master process so that we</span>
  <span style="color: #888888">//can return a matrix.</span>
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> Y_IN_GHOST; y <span style="color: #333333">&lt;</span> Y_IN_GHOST <span style="color: #333333">+</span> my_height; y<span style="color: #333333">++</span>) {
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> X_IN_GHOST; x <span style="color: #333333">&lt;</span> X_IN_GHOST <span style="color: #333333">+</span> my_width; x<span style="color: #333333">++</span>) {
      scatter_buffer_recv[(y <span style="color: #333333">-</span> Y_IN_GHOST) <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x <span style="color: #333333">-</span> X_IN_GHOST] <span style="color: #333333">=</span> universe[y <span style="color: #333333">*</span> my_padded_width <span style="color: #333333">+</span> x];
    }
  }
  MPI_Gather((<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)scatter_buffer_recv,
             my_height <span style="color: #333333">*</span> my_width,
             MPI_UNSIGNED_CHAR,
             (<span style="color: #333399; font-weight: bold">void</span><span style="color: #333333">*</span>)scatter_buffer_send,
             my_height <span style="color: #333333">*</span> my_width,
             MPI_UNSIGNED_CHAR,
             <span style="color: #0000DD; font-weight: bold">0</span>,
             MPI_COMM_WORLD);
  <span style="color: #008800; font-weight: bold">if</span> (rank <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
    out <span style="color: #333333">=</span> (<span style="color: #333399; font-weight: bold">unsigned</span><span style="color: #333333">*</span>)malloc(<span style="color: #008800; font-weight: bold">sizeof</span>(<span style="color: #333399; font-weight: bold">unsigned</span>) <span style="color: #333333">*</span> height <span style="color: #333333">*</span> width);
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> their_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; their_y <span style="color: #333333">&lt;</span> side; their_y<span style="color: #333333">++</span>) {
      <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> their_x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; their_x <span style="color: #333333">&lt;</span> side; their_x<span style="color: #333333">++</span>) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; y <span style="color: #333333">&lt;</span> my_height; y<span style="color: #333333">++</span>) {
          <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">unsigned</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; x <span style="color: #333333">&lt;</span> my_width; x<span style="color: #333333">++</span>) {
            out[(their_y <span style="color: #333333">*</span> my_height <span style="color: #333333">+</span> y) <span style="color: #333333">*</span> width <span style="color: #333333">+</span> their_x <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x] <span style="color: #333333">=</span>
            scatter_buffer_send[(their_y <span style="color: #333333">*</span> side <span style="color: #333333">+</span> their_x) <span style="color: #333333">*</span> (my_width <span style="color: #333333">*</span> my_height) <span style="color: #333333">+</span> y <span style="color: #333333">*</span> my_width <span style="color: #333333">+</span> x];
          }
        }
      }
    }
  }

  aligned_free(new);
  aligned_free(universe);
  aligned_free(ghost_buffer_top_left_send);
  aligned_free(ghost_buffer_top_send);
  aligned_free(ghost_buffer_top_right_send);
  aligned_free(ghost_buffer_right_send);
  aligned_free(ghost_buffer_bottom_right_send);
  aligned_free(ghost_buffer_bottom_send);
  aligned_free(ghost_buffer_bottom_left_send);
  aligned_free(ghost_buffer_left_send);
  aligned_free(ghost_buffer_top_left_recv);
  aligned_free(ghost_buffer_top_recv);
  aligned_free(ghost_buffer_top_right_recv);
  aligned_free(ghost_buffer_right_recv);
  aligned_free(ghost_buffer_bottom_right_recv);
  aligned_free(ghost_buffer_bottom_recv);
  aligned_free(ghost_buffer_bottom_left_recv);
  aligned_free(ghost_buffer_left_recv);
  <span style="color: #008800; font-weight: bold">if</span> (rank <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
    aligned_free(scatter_buffer_send);
  }
  aligned_free(scatter_buffer_recv);
  <span style="color: #008800; font-weight: bold">return</span> out;
}
</pre></div>

    <p>This code runs our 8192x8192 problem for 256 iterations in 0.58 seconds, a speedup of 462.30x over the reference code. Another benefit to this code is that it can scale to arbitrarily large life grid sizes given additional processors. Since the focus of this guide is on-node, we only give numbers for our particular node. Here is a table showing the various times, speedups, and percentages of peak for each code:<p>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">Code</th>
    <th class="tg-yw4l">Time (seconds)</th>
    <th class="tg-yw4l">Speedup (over reference.c)</th>
    <th class="tg-yw4l">% of peak</th>
  </tr>
  <tr>
    <td class="tg-yw4l">reference.c</td>
    <td class="tg-yw4l">268.33</td>
    <td class="tg-yw4l">1.00</td>
    <td class="tg-yw4l">0.05</td>
  </tr>
  <tr>
    <td class="tg-yw4l">simple.c</td>
    <td class="tg-yw4l">208.35</td>
    <td class="tg-yw4l">1.29</td>
    <td class="tg-yw4l">0.06</td>
  </tr>
  <tr>
    <td class="tg-yw4l">padded.c</td>
    <td class="tg-yw4l">51.59</td>
    <td class="tg-yw4l">5.20</td>
    <td class="tg-yw4l">0.24</td>
  </tr>
  <tr>
    <td class="tg-yw4l">sse2.c</td>
    <td class="tg-yw4l">4.62</td>
    <td class="tg-yw4l">58.06</td>
    <td class="tg-yw4l">2.68</td>
  </tr>
  <tr>
    <td class="tg-yw4l">avx2.c</td>
    <td class="tg-yw4l">3.71</td>
    <td class="tg-yw4l">72.42</td>
    <td class="tg-yw4l">3.34</td>
  </tr>
  <tr>
    <td class="tg-yw4l">streaming.c</td>
    <td class="tg-yw4l">3.10</td>
    <td class="tg-yw4l">86.44</td>
    <td class="tg-yw4l">3.99</td>
  </tr>
  <tr>
    <td class="tg-yw4l">omp.c</td>
    <td class="tg-yw4l">0.71</td>
    <td class="tg-yw4l">375.60</td>
    <td class="tg-yw4l">17.34</td>
  </tr>
  <tr>
    <td class="tg-yw4l">mpi.c</td>
    <td class="tg-yw4l">0.58</td>
    <td class="tg-yw4l">462.30</td>
    <td class="tg-yw4l">21.34</td>
  </tr>
</table>

    <p>You may be wondering why the mpi.c runs faster than the omp.c. After all, omp.c performs as well at 10 threads as it does at 40 threads, and mpi.c has a lot of extra copying into buffers, etc. I suspect that because the MPI code explicitly manages communication, passing only the ghost zones to its neighbors once every couple of iterations, mpi.c spends less time in communication. The OpenMP version of the code leaves the communication to the cache, which doesn't know or care about our delicate ghost zones. By keeping two MPI processes on each NUMA node with 10 OpenMP threads each, we can explicitly manage communication between NUMA nodes.</p>

    <p>Hopefully you had as much fun reading this code as I did writing it. This writeup is heavy on code and light on analysis, but the main takeaway here is that a balance of memory, communication, and computation optimizations are necessary to get the full performance out of your system.</p>

    <p>LA-CC-17-018<p>

  </body>
</html>
